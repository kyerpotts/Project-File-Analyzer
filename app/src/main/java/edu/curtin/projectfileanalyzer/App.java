/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package edu.curtin.projectfileanalyzer;

import edu.curtin.projectfileanalyzer.directoryparser.FileParserComposite;
import edu.curtin.projectfileanalyzer.directoryparser.ParserDirectory;
import edu.curtin.projectfileanalyzer.directoryparser.ParserFile;
import edu.curtin.projectfileanalyzer.directoryvalidator.DirectoryValidator;
import java.io.File;
import java.io.IOException;
import java.util.logging.Logger;

public class App {
    // TODO: Log appropriately throughout this class
    private static final Logger LOGGER = Logger.getLogger(App.class.getName());

    public static void main(String[] args) {
        File rootFile;
        DirectoryValidator dirValidator = new DirectoryValidator();
        boolean executeProgram = false; // Determines whether program can continue without major errors

        try {
            // Retrieve the path provided by the user or set default path (current
            // directory)
            rootFile = new File(dirValidator.determinePath(args));
            // Check that path points to valid directory
            executeProgram = dirValidator.isValidPath(rootFile);
        } catch (DirectoryPathException e) {
            // The use has entered to many args when executing the program
            System.out.println("FATAL ERROR: " + e.getMessage());
            return;
        }

        if (executeProgram == true) {
            ParserDirectory rootParser = new ParserDirectory(rootFile.getName());
            buildFileParser(rootFile, rootParser);
        }
    }

    /**
     * Builds a FileParser tree structure recursively
     *
     * @param directory the current File object that the function is recursing
     *                  over. This must always be a directory
     * @param parent    The current ParserDirectory that the function is
     *                  recursively
     *                  adding new children to
     */
    private static void buildFileParser(File directory, ParserDirectory parent) {
        LOGGER.info("Building parser directory " + parent.getName() + ".");
        // Iterates through the files contained within the directory given and
        // creates a ParserFile and adds the content of the file, or creates a
        // ParserDirectory and calls the buildFileParser function recursively to
        // continue generating the tree structure. This ensures that all files and
        // directories contained within root are built into the FileParserComposite
        // tree.
        for (File file : directory.listFiles()) {
            if (file.isFile()) {
                ParserFile newParserFile = new ParserFile(file.getName());
                try {
                    newParserFile.addFileData(file);
                } catch (IOException e) {
                    System.out.println(
                            "Problem adding data to" + newParserFile.getName() +
                                    " occured. Parser tree data may not be accurate for the purposes of reporting.");
                }
                parent.addChild(newParserFile);
            } else if (file.isDirectory()) {
                ParserDirectory newParent = new ParserDirectory(file.getName());
                parent.addChild(newParent);
                // Calls this function recursively on the currently obtained File and
                // newly created ParentDirectory to ensure that the FileParserComposite
                // tree is completely built
                buildFileParser(file, newParent);
            }
        }
        LOGGER.info("Parser directory " + parent.getName() + " completed.");
    }

    // private void executeMenu(FileParserComposite fileParser) {
    // boolean continueMenuLoop = true;
    // }
}
