/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package edu.curtin.projectfileanalyzer;

import edu.curtin.projectfileanalyzer.directoryparser.FileParserComposite;
import edu.curtin.projectfileanalyzer.directoryparser.ParserDirectory;
import edu.curtin.projectfileanalyzer.directoryparser.ParserFile;
import edu.curtin.projectfileanalyzer.directoryvalidator.DirectoryValidator;
import edu.curtin.projectfileanalyzer.matcher.CriteriaMatcher;
import edu.curtin.projectfileanalyzer.matcher.MatcherBuilder;
import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.logging.Logger;

public class App {
    // TODO: Log appropriately throughout this class
    private static final Logger LOGGER = Logger.getLogger(App.class.getName());

    public static void main(String[] args) {
        File rootFile = null;
        DirectoryValidator dirValidator = new DirectoryValidator();
        boolean executeProgram = false; // Determines whether program can continue without major errors

        try {
            // Retrieve the path provided by the user or set default path (current
            // directory)
            rootFile = new File(dirValidator.determinePath(args));
            // Check that path points to valid directory
            executeProgram = dirValidator.isValidPath(rootFile);
        } catch (DirectoryPathException e) {
            // The use has entered to many args when executing the program
            System.out.println("FATAL ERROR: " + e.getMessage());
        }

        if (executeProgram == true) {
            ParserDirectory rootParser = new ParserDirectory(rootFile.getName());
            buildFileParser(rootFile, rootParser);
            executeMenu(rootParser);
        } else {
            System.out.println(
                    "Provided path does not point to a directory on this system: " +
                            rootFile.getName());
            System.out.println("Please check the path and try again.");
        }
    }

    /**
     * Builds a FileParser tree structure recursively
     *
     * @param directory the current File object that the function is recursing
     *                  over. This must always be a directory
     * @param parent    The current ParserDirectory that the function is
     *                  recursively
     *                  adding new children to
     */
    private static void buildFileParser(File directory, ParserDirectory parent) {
        LOGGER.info(() -> "Building parser directory " + parent.getName() + ".");
        // Iterates through the files contained within the directory given and
        // creates a ParserFile and adds the content of the file, or creates a
        // ParserDirectory and calls the buildFileParser function recursively to
        // continue generating the tree structure. This ensures that all files and
        // directories contained within root are built into the FileParserComposite
        // tree.
        for (File file : directory.listFiles()) {
            if (file.isFile()) {
                ParserFile newParserFile = new ParserFile(file.getName());
                try {
                    newParserFile.addFileData(file);
                } catch (IOException e) {
                    System.out.println(
                            "Problem adding data to" + newParserFile.getName() +
                                    " occured. Parser tree data may not be accurate for the purposes of reporting.");
                }
                parent.addChild(newParserFile);
            } else if (file.isDirectory()) {
                ParserDirectory newParent = new ParserDirectory(file.getName());
                parent.addChild(newParent);
                // Calls this function recursively on the currently obtained File and
                // newly created ParentDirectory to ensure that the FileParserComposite
                // tree is completely built
                buildFileParser(file, newParent);
            }
        }
        LOGGER.info(() -> "Parser directory " + parent.getName() + " completed.");
    }

    private static void executeMenu(FileParserComposite fileParser) {
        BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
        String userInput = "";
        boolean continueMenuLoop = true;
        while (continueMenuLoop) {
            System.out.println("Please choose from the following options:");
            System.out.println("1: Set Report Criteria");
            System.out.println("2: Set Report Output Format");
            System.out.println("3: Generate Report");
            System.out.println("4: Quit");
            try {
                userInput = input.readLine();

            } catch (IOException e) {
                LOGGER.warning(() -> "User input error: " + e.getMessage());
            }
            // Guard condition ensures switch case is not reading a null value from
            // the userInput variable
            if (userInput == null) {
                userInput = "";
            }

            CriteriaMatcher criteriaMatcher;
            switch (userInput) {
                case "1":
                    criteriaMatcher = addCriteria(input);
                    break;
                case "2":
                    // TODO: build reportOutput method
                    break;
                case "3":
                    // TODO: build generateReport method
                    break;
                case "4":
                    continueMenuLoop = false;
                    break;
                default:
                    System.out.println("Invalid menu option");
                    break;
            }
        }
        System.out.println("Exiting Project File Analyzer. Goodbye.");
        try {
            input.close();
        } catch (IOException e) {
            LOGGER.severe(() -> e.getMessage());
        }
    }

    /**
     * Method allows the user to add criteria to the report
     *
     * @param input An input reader to allow the user to enter criteria from the
     *              keyboard.
     * @return CriteriaMatcher with completed LineMatcher objects based on user
     *         entered criteria.
     */
    private static CriteriaMatcher addCriteria(BufferedReader input) {
        MatcherBuilder matcherBuilder = new MatcherBuilder();
        // Request criteria from the user
        matcherBuilder.requestMatcherInput(input);
        // The CriteriaMatcher object must be returned so it can be given to the
        // ReportType object
        return matcherBuilder.buildCriteriaMatcher();
    }
}
